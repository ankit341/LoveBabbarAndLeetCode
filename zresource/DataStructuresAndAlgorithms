What is problem solving - There will be a lot of methods to solve a single problem. So your wisdom and knowledge to think of ways through which the problem can be solved
                          is called the problem solving skills. But there is also a point to select the best method out of all the methods you were able to think.
                          It depends on the complexity analysis.
So you tend to solve the problem with the best time complexity for a method you can think of. It should also have a trade off between space and time complexity.
Example - You thought of two solutions for a problem. One with O(n) and other with O(logn). So you now need to present the best complexity solution in front of the interviewer

So when solving a problem using your problem solving skills you should calculate the time and space complexity when you write the pseudo code for the solution.

So the last piece of cracking the coding interview is the calculation of time complexity.

So to think of a method in the problem solving, you will need two things,
        -In what way you will accommodate the data which is given to solve the problem.
        -And in what way you will process that data to come to a conclusion.

So for that you need to learn how to save/accommodate the data, and in what way you have decided to process them.

Accommodating the data in a distinguished way is called as Data structures.
And finding a way to process them is called as the Algorithms. They may be known and general or they may be new as per your intuition and specific to the problem defined.

So we have the list of data structures that should be known at any cost.

There may be operations for a particular data structure, but that will always be finite. And there will not be any other operations that can happen over that DS apart from
the one defined.
Also you need to understand and get acquainted to the fact that if a data structure has an independent implementation or does it depend on any other data structure for its
implementation or it can be done in both the ways specified.

After this learning of all the data structures, you need to learn the renowned algorithms which are proven to give a desired result based on the DS you use.

This may be specific to a kind of problem or it may be specific to a DS only.
But this comes only after you are thorough with all these basic DS and the operations related to them.

So when you know the DS thoroughly, and you are also aware with the algorithms, then you can see a problem and then think which DS will suit it the best and if there is a
learnt algorithm which suits the problem or you have to think a question specific algorithm definition then you are good to solve the problem.

Stages to solve the problem -
    - Concluding which DS suits it best
    - Validating if there is an algorithm learnt that suits the need.
    - Writing pseudo code
    - Running 2-3 test cases, Maybe Edge cases? If you find some.
    - Analysing the Time Complexity
    - Validating the thinking with the interviewer.
    - Writing a clean code
    - Doing a dry run.

Now let us dive into the basics and the paradigm of learning.

List of All the Data Structures -

    Linked Lists
    Stacks
    Queues
    Maps & Hash Tables
    Arrays
    Graphs
    Trees
    Binary Trees & Binary Search Trees
    Self-balancing Trees (AVL Trees, Red-Black Trees, Splay Trees)
    Heaps
    Tries
    Segment Trees
    Fenwick Trees
    Disjoint Set Union
    Minimum Spanning Trees

List of All the Algorithms you will learn -

    Divide and Conquer
    Sorting Algorithms (Bubble Sort, Counting Sort, Quick Sort, Merge Sort, Radix Sort)
    Searching Algorithms (Linear Search, Binary Search)
    Sieve of Eratosthenes
    Knuth-Morris-Pratt Algorithm
    Greedy I (Maximum number of non-overlapping intervals on an axis)
    Greedy II (Fractional Knapsack Problem)
    Dynamic Programming I (0â€“1 Knapsack Problem)
    Dynamic Programming II (Longest Common Subsequence)
    Dynamic Programming III (Longest Increasing Subsequence)
    Convex Hull
    Graph Traversals (Breadth-First Search, Depth-First Search)
    Floyd-Warshall / Roy-Floyd Algorithm
    Dijkstra's Algorithm & Bellman-Ford Algorithm
    Topological Sorting

learning to calculate the Time and space complexity.
    Learn notations and refer to the abdul baari videos for time complexity analysis.


DS Specific information -

1.Arrays
    Operations performed on Array as a whole  - Creation
                                                Deletion
                                                Traversing
                                                Sorting
                                                Merging

    Operations performed on Array Elements    - Searching
                                                Swapping
                                                Deleting without shifting
                                                Deleting with shifting
                                                Updating
                                                Inserting with shifting
                                                Inserting without shifting

    Algorithms which are specific to array
        - Searching - Linear Search, Binary Search
        - Sorting   - Bubble Sort, Insertion sort, Selection sort, Merge Sort, Quick sort, Counting sort, Bucket Sort, Shell Sort, Sleep Sort
        - Sorting with help of other DS - Heap Sort.
        - Also refer to the sorting algorithms from - https://www.geeksforgeeks.org/sorting-algorithms/

    - Learn the time complexity Management along side every algorithms implemented

2.Linked List
    Types of Linked List                             - Singly Linked List
                                                       Doubly Linked List
                                                       Circular Linked List
                                                       ----- Skip Lists -----

    Operations performed on a Linked List as a whole - Creation
                                                       Deletion
                                                       Traversing
                                                       Merging

    Operations performed on a Linked List elements   - Creating a node
                                                       Inserting a node front/last
                                                       Inserting before/after a value
                                                       Updating a node value
                                                       Sorting
                                                       Searching
                                                       Deleting a node with a value
                                                       Deleting a node before/after a given value.

    Algorithms specific to linked list
        - Searching - Linear Search, Binary Search "Why binary search gives no value to linked list"
        - Sorting   - Merge sort, Why merge sort is preferred over in linked list instead of quick sort, despite of same complexity.


    - learning of the time complexity of each operations and if internally there is reason to support one kind of operation over the other.


